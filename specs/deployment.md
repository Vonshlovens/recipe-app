# Deployment

> Hosting, CI/CD, environment config, Deno Deploy or alternative.

---

## Overview

This spec defines how the recipe app is built, tested, and deployed to production. We use **Deno Deploy** as the primary hosting platform, leveraging its native Deno runtime support, edge network, and zero-config TLS. GitHub Actions handles CI/CD with automated testing, building, and deployment on merge to `main`.

This spec builds on:
- [backend-architecture.md](./backend-architecture.md) — Deno runtime, API layer
- [database.md](./database.md) — database connection and migrations
- [frontend-architecture.md](./frontend-architecture.md) — SvelteKit build output
- [auth.md](./auth.md) — secrets and session config

---

## Hosting: Deno Deploy

### Decision

| Option          | Pros                                              | Cons                                            |
|-----------------|---------------------------------------------------|-------------------------------------------------|
| Deno Deploy     | Native Deno, edge network, zero-config TLS, free tier | Limited compute time, no persistent disk        |
| Fly.io          | Docker support, persistent volumes, global regions   | Requires Dockerfile, more config                |
| Railway         | Easy deploy, managed Postgres addon                  | Less Deno-native, cold starts                   |
| Self-hosted VPS | Full control, persistent disk                        | Manual TLS, updates, scaling                    |

**Choice: Deno Deploy.** It aligns with our Deno runtime, provides edge distribution, and requires minimal infrastructure configuration. SvelteKit has a dedicated Deno Deploy adapter.

### SvelteKit Adapter

Use `svelte-adapter-deno` to produce Deno Deploy-compatible output.

```ts
// svelte.config.js
import adapter from 'svelte-adapter-deno';

export default {
  kit: {
    adapter: adapter({
      out: 'build',
    }),
  },
};
```

### Deployment Target

- **Platform:** Deno Deploy
- **Entry point:** `build/server.ts` (generated by adapter)
- **Region:** Auto (edge — requests routed to nearest region)
- **Custom domain:** Configured via Deno Deploy dashboard + DNS CNAME

---

## Environment Configuration

### Environment Variables

All secrets and configuration are stored as environment variables, never committed to source.

| Variable              | Description                        | Required | Example                            |
|-----------------------|------------------------------------|----------|------------------------------------|
| `DATABASE_URL`        | PostgreSQL connection string       | Yes      | `postgresql://user:pass@host/db`   |
| `SESSION_SECRET`      | Secret for signing session cookies | Yes      | 64-char random hex string          |
| `OCR_API_KEY`         | API key for OCR service            | Yes      | `sk-...`                           |
| `PUBLIC_BASE_URL`     | Public-facing app URL              | Yes      | `https://recipes.example.com`      |
| `NODE_ENV`            | Environment identifier             | No       | `production` (default)             |

### Environment Files

```
.env              # Local development (gitignored)
.env.example      # Template with placeholder values (committed)
```

### Deno Deploy Environment

Environment variables are set via the Deno Deploy dashboard or CLI:

```bash
deployctl deploy --env DATABASE_URL=... --env SESSION_SECRET=...
```

---

## CI/CD: GitHub Actions

### Pipeline Overview

```
push/PR to main
  └─ Install dependencies
  └─ Lint (deno lint)
  └─ Type check (deno check)
  └─ Unit tests (deno test)
  └─ Build (SvelteKit build)
  └─ Deploy (only on merge to main)
```

### Workflow File

File: `.github/workflows/deploy.yml`

```yaml
name: CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  id-token: write  # Required for Deno Deploy

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Lint
        run: deno lint

      - name: Type check
        run: deno check src/**/*.ts

      - name: Test
        run: deno test --allow-read --allow-env
        env:
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}

      - name: Build
        run: deno task build

      - name: Deploy to Deno Deploy
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        uses: denoland/deployctl@v1
        with:
          project: recipe-app
          entrypoint: build/server.ts
```

### Branch Protection

- **Required checks before merge:** ci (lint, type check, test, build)
- **No direct pushes to `main`** — all changes via pull request
- **Auto-delete head branches** after merge

---

## Build Process

### Build Command

```bash
deno task build
```

Defined in `deno.json`:

```json
{
  "tasks": {
    "dev": "deno run -A npm:vite dev",
    "build": "deno run -A npm:vite build",
    "preview": "deno run -A npm:vite preview"
  }
}
```

### Build Output

```
build/
├── server.ts          # Deno Deploy entry point
├── client/            # Static assets (JS, CSS, images)
│   └── _app/
│       ├── immutable/ # Hashed, long-cache assets
│       └── version.json
└── prerendered/       # Pre-rendered static pages (if any)
```

### Static Asset Caching

- `immutable/` assets: `Cache-Control: public, max-age=31536000, immutable`
- Other assets: `Cache-Control: public, max-age=3600`

---

## Database Migrations

Migrations run as a separate step before deployment, not during app startup.

### Migration Strategy

```bash
# Run pending migrations against production database
deno task migrate:deploy
```

Defined in `deno.json`:

```json
{
  "tasks": {
    "migrate:deploy": "deno run --allow-net --allow-env src/lib/server/db/migrate.ts"
  }
}
```

### CI/CD Integration

Migrations run after tests pass but before the deploy step. The migration script:
1. Connects to the production database
2. Acquires an advisory lock (prevents concurrent migration runs)
3. Runs all pending migrations in order
4. Releases the lock

### Rollback

Migrations are forward-only. To fix a bad migration, create a new migration that reverses the change.

---

## Health Check

### Endpoint

```
GET /api/v1/health
```

### Response

```json
{
  "status": "ok",
  "version": "1.0.0",
  "timestamp": "2025-01-15T12:00:00Z"
}
```

The health endpoint verifies:
- App is responding
- Database connection is alive (simple `SELECT 1` query)

### Monitoring

- **Uptime:** Deno Deploy dashboard or external uptime monitor (e.g., UptimeRobot)
- **Errors:** Console logs via Deno Deploy log viewer
- **Metrics:** Request count, latency, and error rate via Deno Deploy analytics

---

## Preview Deployments

Pull requests get automatic preview deployments via Deno Deploy's GitHub integration.

- **URL pattern:** `https://recipe-app-{pr-number}.deno.dev`
- **Lifecycle:** Created on PR open/update, deleted on PR close
- **Database:** Preview deployments use a shared staging database
- **Environment:** Same variables as production except `PUBLIC_BASE_URL` points to the preview URL

---

## Security Checklist

- [ ] All secrets in environment variables, never in code
- [ ] `.env` in `.gitignore`
- [ ] `SESSION_SECRET` is unique per environment (dev, staging, production)
- [ ] Database connection uses TLS (`?sslmode=require`)
- [ ] CORS configured to allow only `PUBLIC_BASE_URL` origin
- [ ] Rate limiting on auth endpoints
- [ ] Content Security Policy headers set
- [ ] `X-Frame-Options: DENY` header set

---

## Rollback Procedure

If a deployment causes issues:

1. **Instant rollback:** Deno Deploy supports instant rollback to the previous deployment via the dashboard
2. **Git revert:** Create a revert commit and push to `main` to trigger a new deployment
3. **Database:** If a migration caused the issue, deploy a new migration to reverse the change

---

## Cost Considerations

### Deno Deploy Free Tier

- 1M requests/month
- 100 GiB bandwidth/month
- KV storage included

### When to Scale

- Exceeding free tier limits → Deno Deploy Pro ($20/month)
- Need persistent background jobs → Consider a separate worker on Fly.io
- Need larger database → Upgrade managed Postgres plan
